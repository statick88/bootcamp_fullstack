:::{.justify}
# Tienda Virtual.

:::{.center}
![Tienda Virtual](./images/tienda-virtual-profesional.png){width=50%}
:::

## Descripción del Proyecto

Este proyecto tiene como objetivo construir una tienda virtual escalable y moderna utilizando **Django** para el backend, **React** con Vite, **TailwindCSS** y **TypeScript** para el frontend, y **PostgreSQL** como base de datos. Se utilizará **Docker** para crear un entorno de desarrollo consistente, con contenedores separados para el backend, frontend y base de datos. El sistema integrará **PayPal Sandbox** para pagos y será desplegado en Railway (backend) y Vercel (frontend).

Se priorizarán buenas prácticas, seguridad, accesibilidad y cumplimiento legal para garantizar un sistema robusto y listo para producción.

## Objetivos

### Objetivo General

Desarrollar una tienda virtual con arquitectura modular y tecnologías modernas, optimizada para escalabilidad, seguridad, accesibilidad y rendimiento.

### Objetivos Específicos

1. Implementar un backend funcional con **Django** y **Django REST Framework**, con autenticación basada en **JWT** y gestión segura de datos con **PostgreSQL**.

2. Diseñar un frontend interactivo, accesible y responsivo con **React**, utilizando Vite, **TailwindCSS** y **TypeScript**.
3. Integrar pagos con **PayPal Sandbox** y explorar opciones para múltiples métodos de pago.

4. Configurar un entorno dockerizado con tres contenedores, garantizando comunicación eficiente entre backend y base de datos.

5. Implementar un flujo de CI/CD con despliegue automatizado en **Railway** y **Vercel**.
6. Asegurar cumplimiento legal y normativo (e.g., GDPR), accesibilidad (a11y) y monitoreo continuo del sistema.

## Fases del Proyecto

### Fase 1: Recolección de Requisitos

#### Requisitos Funcionales

**Usuarios**:

- Registro, inicio de sesión y gestión de perfiles (roles: cliente y administrador).

- Recuperación de contraseña y manejo de autenticación de dos factores (2FA).

**Productos**:

- CRUD para gestión de productos.
- Gestión de imágenes con integración a servicios externos (e.g., AWS S3, Google Cloud Storage).

**Carrito y Pedidos**:

- Gestión de carritos de compra y creación de pedidos.
- Estados de pedidos (e.g., pendiente, procesado, enviado, cancelado).

**Pagos**:

- Integración con PayPal Sandbox y soporte para otros métodos (e.g., Stripe).
- Validación de pagos y actualizaciones automáticas de pedidos.

**Accesibilidad y SEO**:

- Frontend accesible para personas con discapacidades.
- Optimización para motores de búsqueda (SEO).

**Requisitos Técnicos**

**Backend**:

- **Django** y **Django REST Framework** para la API.
- Autenticación JWT con roles de usuario.
- Configuración de caché con **Redis**.

**Frontend**:

- **React** con **Vite**, **TailwindCSS** y **TypeScript**.
- Lazy loading y code splitting para optimizar rendimiento.
- Uso de Axios para consumir APIs.

**Infraestructura**:

- Contenedores Docker orquestados con Docker Compose.
- Red interna para comunicación entre contenedores (backend y base de datos).
- Configuración para manejo seguro de variables de entorno.

**Despliegue**:

- Backend desplegado en **Railway**.
- Frontend desplegado en **Vercel**.
- Flujo CI/CD para despliegue automatizado.

## Fase 2: Diseño del Sistema

### Arquitectura General

**Backend**:

- Módulos de Django para usuarios, productos, pedidos y pagos.
- Endpoints REST con DRF para CRUD y gestión de transacciones.
- Configuración de variables de entorno para manejar credenciales y secretos.

**Frontend**:

- Componentes reutilizables (Navbar, ProductCard, Cart, CheckoutForm).
- Rutas principales:
  - **Home**: Lista de productos.
  - **Product Details**: Detalles de un producto.
  - **Cart**: Resumen del carrito.
  - **Checkout**: Procesar pedidos y pagos.
  - **Profile**: Gestión de perfil.

**Infraestructura**:

- Configuración de Docker Compose:
  - **Base de datos**: Contenedor PostgreSQL con persistencia de datos.
  - **Backend**: Contenedor Django con conexión a la base de datos.
  - **Frontend**: Contenedor React conectado al backend.

## Fase 3: Configuración Inicial

1. Crear la estructura inicial del proyecto con directorios separados para backend y frontend.
2. Configurar un archivo **docker-compose.yml** para orquestar contenedores.
3. Crear **.env** para variables de entorno:
  - **Backend**: **DATABASE_URL**, **SECRET_KEY**, **PAYPAL_CLIENT_ID**.
  - **Frontend**: URL del backend, claves de API.
4. Configurar TailwindCSS en el frontend.
5. Inicializar el repositorio Git con un .gitignore adecuado.

## Fase 4: Desarrollo del Backend

1. Crear modelos y relaciones:
  - **User**: Roles (cliente y administrador).
  - **Product**: Detalles (nombre, precio, inventario, imágenes).
  - **Order**: Asociado a usuarios y productos.

2. Configurar vistas y serializadores con **Django REST Framework**.
3. Implementar autenticación basada en **JWT**.
4. Configurar endpoints seguros para:
  - Usuarios (registro, login, perfil).
  - Productos (CRUD).
  - Pedidos.
  - Pagos.

## Fase 5: Desarrollo del Frontend

1. Configurar React con **Vite**, **TailwindCSS** y **TypeScript**.
2. Crear componentes reutilizables y rutas principales.
3. Integrar **React Router** para navegación.
4. Consumir APIs del backend con Axios, manejando autenticación y errores.

## Fase 6: Integración de Pagos
1. Configurar PayPal Sandbox en el backend.
2. Implementar lógica en el frontend para manejar transacciones.
3. Validar pagos y actualizar pedidos según estado de transacción.

## Fase 7: Pruebas
1. **Pruebas Unitarias**:
  - **Backend**: Modelos, serializadores, vistas.
  - **Frontend**: Componentes, funciones.

2. **Pruebas de Integración**:
  - Flujo completo (registro → carrito → pago).
3. **Pruebas de Carga**:
  - Simular tráfico alto con herramientas como **Locust** o **JMeter**.

## Fase 8: Despliegue
1. Configurar CI/CD para despliegue automatizado.
2. Desplegar backend en Railway y frontend en Vercel.
3. Validar el sistema completo en producción.

## Fase 9: Optimización y Mantenimiento
1. Optimizar consultas a la base de datos.
2. Implementar monitoreo con herramientas como Grafana y Prometheus.
3. Automatizar backups para la base de datos.
4. Actualizar dependencias y resolver vulnerabilidades.

## Fase 10: Documentación
1. Crear documentación detallada para desarrolladores y usuarios finales.
2. Generar un manual de uso de la API con Swagger.
3. Incluir instrucciones para desarrollo local y despliegue.
:::
